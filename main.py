# -*- coding: utf-8 -*-
"""cancer_3d_modeling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FzblNj_6bWpNg0MEBYslosaAOj1NDKy8
"""

###---------------PROGRAMMERS' NOTES---------------###
''' This python model simulates how cancer cells move and multiply inside of a 3D environment, influenced
by oxygen availability in the medium, a key factor in tumor growth.

How it works:
The simulation starts with a single cancer cell in the center of a cube-shaped 3D grid. Each time step, the cell can:
- Move in a random 3D direction (with a bias toward oxygen heavy areas (increase along the +Z-axis)
- Multiply by spawning new cancer cells.
- Die (hypoxia), especially in low-oxygen areas, mimicking hypoxia-induced cell death.


Visual Outputs:
3D scatter plot of cancer cell locations.

Graphs showing:

Number of cancer cells and walkers over time, a 3D plot model of the end tumor, and a histogram of where cancer cells gather along the Z-axis (oxygen gradient).


A further explanation can be found on the google doc or on this table!
https://docs.google.com/document/d/e/2PACX-1vTDflMkHeRHqR6eE_hPLzX64lPPF2SBlKXN0euCkki0bWPgeaRL9h6GLfpkt--xEqn4V7BV3fxmDQpT/pub

'''
import numpy as np
import matplotlib.pyplot as plt
import random
import config


def move_walker(x,y,z):
    directions = [(1,0,0), (-1,0,0), (0,1,0), (0,-1,0), (0,0,1), (0,0,-1)]
    weights = [1,1,1,1,1+oxygen_bias, 1-oxygen_bias]
    weights = np.array(weights) / np.sum(weights)
    dx, dy, dz = directions[np.random.choice(len(directions), p=weights)]
    nx, ny, nz = x+dx, y+dy, z+dz


    if (0 <= nx <= grid_size) and (0 <= ny <= grid_size) and (0 <= nz <= grid_size):
        return nx, ny, nz
    else:
        return x, y, z


def simulate(grid_size, oxygen_bias, nw_bias, num_steps, max_Walkers):
    positions, walker_counts, cancer_cell_counts = []
    walkers = [((grid_size//2),(grid_size//2),(grid_size//2))]
    grid[((grid_size//2),(grid_size//2),(grid_size//2))] = 1
    oxygen = np.linspace(0,1,grid_size)

    
    for step in range(num_steps): #Cycle checker per walker over steps.
        new_walkers = []
        for i in range(len(walkers)):
            x,y,z = walkers[i]
    
            death_prob = 1 - oxygen[z]
            if random.random() < death_prob * 0.05:
                continue
    
            nx,ny,nz = move_walker(x,y,z)
            if grid[nx,ny,nz] == 0:
                grid[nx, ny, nz] = 1
                walkers[i] = (nx,ny,nz)
                positions.append((nx,ny,nz))
            else:
                continue
    
        if random.random() < 0.02 and positions:
            popped = positions.pop()
            grid[popped[0], popped[1], popped[2]] = 0
        if (len(new_walkers) + len(walkers) <= max_walkers) and (random.random() < nw_bias):
            new_walkers.append((nx, ny, nz))
    
        walkers.extend(new_walkers)
        walker_counts.append(len(walkers))
        cancer_cell_counts.append(len(positions))
    return positions, walker_counts, cancer_cell_counts, grid

def plot_results(positions, walker_counts, cancer_cell_counts, grid):
    # --------- GRAPHING & DISPLAY -----------
    x_steps, y_steps, z_steps = zip(*positions)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.scatter(x_steps, y_steps, z_steps, c = 'red', marker='o')
    
    # 3D Graph
    plt.title("Cancer 3D Walk")
    plt.xlabel("X")
    plt.ylabel("Y")
    ax.set_zlabel("Z")
    plt.show()
    
    # Walker Counts
    plt.figure()
    plt.plot(walker_counts, color='blue')
    plt.title("Walker Counts over Time")
    plt.xlabel("Step")
    plt.ylabel("Walker Counts")
    plt.grid(True)
    plt.show()
    
    # Cancer Cell Counts
    plt.figure()
    plt.plot(cancer_cell_counts, color='orange')
    plt.title("Total Cancer Cells Over Time")
    plt.xlabel("Step")
    plt.ylabel("Total Cancer Cells")
    plt.grid(True)
    plt.show()
    
    #Distribution along the Z-axis
    occupied = np.argwhere(grid == 1)
    #print(occupied)
    x_vals, y_vals, z_vals = occupied[:,0], occupied[:,1], occupied[:,2]
    
    
    plt.figure()
    plt.hist(z_vals, bins=20, color='green', edgecolor='black')
    plt.title("Cancer Cell Distribution Along Z-axis, where the oxygen gradient is found")
    plt.xlabel("Z Position")
    plt.ylabel("Cell Count")
    plt.grid(True)
    plt.show()
def main():
    positions, walker_counts, cancer_cell_counts, grid = simulate(config.GRID_SIZE, config.OXYGEN_BIAS, config.NW_BIAS, config.NUM_STEPS, config.MAX_WALKERS))
    plot_results(positions, walker_counts, cancer_cell_counts, grid)
if __name__ = "__main__"":
    main()
